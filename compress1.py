# -*- coding: utf-8 -*-
"""compress.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/dclcs/multiwork/blob/master/compress.ipynb
"""

import struct
import numpy as np

def read_from_origin():
    with open("origin_compression.txt", 'r') as f:
        source = f.read()
    return source

def split_data(data):
    folds = []
    ys = len(data) % 8
    if ys != 0:
        #  如果不能被8除则后续补零
        data += "0" * ys
        print("补充的0的个数:",ys)
    size = len(data)
    num_folds = int(size / 8)
    i = 0
    index_split = np.array_split(np.arange(size),indices_or_sections=num_folds)
    for i in index_split:
        cell = data[i[0]:i[-1] + 1]
        folds.append(cell)
    return folds

def refine_list(data):
    lists = []
    for i in data:
        if i not in lists:
            lists.append(i)
    return sorted(lists)

def LWZ(list_bytes, dicts):
    p = ""
    result = []
    last = 256
    for c in list_bytes:
        pc = p + c
        if pc in dicts:
            p = pc
        else:
            result.append(dicts[p])
            dicts[pc] = last
            last += 1
            p = c
    return result, dicts

def convert_to_byte(result):
    b_result = []
    i = 0
    code = ""
    while i < len(result):
        b_result.append(bin(result[i])[2:])
        temp = bin(result[i])[2:]
        code += temp
        i = i + 1
    return code


source = read_from_origin() ## 从原始文件读取数据 type : str

print("原始数据的长度：",len(source))
s_length = len(source)

sdata = split_data(source)  # 将str每8个分成一个码子

print("每8位作为一个码子长度为：",len(sdata))

with open('result_original.txt', 'wb+') as f:
    i = 0
    while i < len(sdata):
        wb = struct.pack('B', int(sdata[i],2))
        f.write(wb)
        i = i + 1
print("...result_original.txt")

dicts = dict(zip(refine_list(sdata), [i for i in range(len(refine_list(sdata)))]))

print("初始化字典的长度：",len(dicts))

result, dicts = LWZ(sdata, dicts)

# print(result)
code = convert_to_byte(result)
print("压缩后的长度：",len(code))
c_length = len(code)
scode = split_data(code)
print("压缩后的码子:",len(scode))
size = len(scode)
with open('result.txt', 'wb+') as f:
    i = 0
    while i < size:
        wb = struct.pack('B', int(scode[i],2))
        f.write(wb)
        i = i + 1
print("...保存在result.txt")

with open("log/lzz_1.txt", "w+") as f:
    # f.write("")
    f.write("original length:")
    f.write(str(s_length))
    f.write("\nafter compress length:")
    f.write(str(c_length))
    